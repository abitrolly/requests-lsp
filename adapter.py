"""Requests adapter implementing a CURL backend"""

import six
import pycurl

from requests.exceptions import (
    ConnectionError, ConnectTimeout, ReadTimeout, SSLError,
    ProxyError, RetryError, InvalidSchema, InvalidProxyURL,
    InvalidURL, RequestException
)
from requests.structures import CaseInsensitiveDict
from requests.utils import get_encoding_from_headers
from requests.adapters import BaseAdapter
from requests import Response as RequestResponse
from urllib3.util.retry import Retry
from urllib3.exceptions import MaxRetryError
from urllib3.response import HTTPResponse as URLLib3Rresponse


DEFAULT_RETRIES = 3


class CURLRequest(object):
    """Implementation of a request using PyCURL."""

    def __init__(self):
        self._curl_handler = pycurl.Curl()
        self._response_headers = []
        self._response_reason = None

        # This configuration does not depend on the request itself, so
        # we do it once here.
        self._curl_handler.setopt(pycurl.HEADERFUNCTION,
                                  self._parse_header_line)

    def configure(self, request):
        pass

    def send(self, request, stream=False, timeout=None, verify=True,
             cert=None):
        """Performs the request using PyCURL, and upon success, returns a
        requests.Response instance. If there is an error, then the error
        generated by PyCURL will be translated to the most suitable
        requests exception.

        Args:
            request (PreparedRequest): the request being sent.
            stream (bool, optional): Defaults to False. Whether to stream the
                request content.
            timeout (float, optional): Defaults to None. How long to wait for
                the server to send data before giving up, as a float, or a
                `(connect timeout, read timeout)` tuple.
            verify (bool, optional): Defaults to True. Either a boolean, in
                which case it controls whether we verify the server's TLS
                certificate, or a string, in which case it must be a path
                to a CA bundle to use.
            cert (str, optional): Defaults to None. Any user-provided SSL
                certificate to be trusted.

        Raises:
            requests.exceptions.SSLError: if request failed due to a SSL error.

        Returns:
            request.Response: the response to the request.
        """

        try:
            self.configure(request)

            body = self._curl_handler.perform_rb()

            response = self._create_requests_response(request,
                                                      six.StringIO(body))

            return response
        except pycurl.error as ex:
            requests_exception = translate_curl_exception(ex)

            raise requests_exception

    def _parse_header_line(self, header_line):
        """This callback will be invoked when parsing each line of the
        response's headerds.

        Args:
            header_line (str): a line of the headers section.
        """

        # HTTP standard specifies that headers are encoded in iso-8859-1.
        header_line = header_line.decode('iso-8859-1')

        # Header lines include the first status line (HTTP/1.x ...).
        # We are going to ignore all lines that don't have a colon in them.
        # This will botch headers that are split on multiple lines...
        if ':' not in header_line:
            # Also, reset headers
            self._response_headers = []
            return

        name, value = header_line.split(':', 1)
        self._response_headers[name.strip().lower()] = value.strip()

    def _create_requests_response(self, request, body):
        """Creates a requests.Response instance to be returned after a curl request.

        Args:
            request ([type]): [description]
            body ([type]): [description]

        Returns:
            request.Response: the generated response.
        """

        urllib3_response = URLLib3Rresponse(
            body=body,
            headers=self._response_headers,
            status=self._curl_handler.getinfo(pycurl.HTTP_CODE),
            request_method=request.method,
            reason=self._response_reason
        )

        response = RequestResponse()
        response.request = request
        response.raw = urllib3_response
        response.status_code = response.raw.status
        response.reason = response.raw.reason
        response.headers = CaseInsensitiveDict(response.raw.headers)
        response.encoding = get_encoding_from_headers(response.headers)

        request.cookies.extract_cookies_to_jar(response.cookies,
                                               request,
                                               urllib3_response)

        if isinstance(request.url, six.binary_type):
            response.url = request.url.decode("utf-8")
        else:
            response.url = request.url

        return response


class CURLAdapter(BaseAdapter):
    """A requests adapter implemented using PyCURL"""

    def __init__(self, max_retries=DEFAULT_RETRIES):
        super(CURLAdapter, self).__init__()

        if max_retries == DEFAULT_RETRIES:
            self.max_retries = Retry(0, read=False)
        else:
            self.max_retries = Retry.from_int(max_retries)

    def send(self, request, stream=False, timeout=None, verify=True, cert=None,
             proxies=None):
        """Sends PreparedRequest object using PyCURL. Returns Response object.

        Args:
            request (PreparedRequest): the request being sent.
            stream (bool, optional): Defaults to False. Whether to stream the
                request content.
            timeout (float, optional): Defaults to None. How long to wait for
                the server to send data before giving up, as a float, or a
                `(connect timeout, read timeout)` tuple.
            verify (bool, optional): Defaults to True. Either a boolean, in
                which case it controls whether we verify the server's TLS
                certificate, or a string, in which case it must be a path
                to a CA bundle to use.
            cert (str, optional): Defaults to None. Any user-provided SSL
                certificate to be trusted.
            proxies (dict,  optional): Defaults to None. The proxies
                dictionary to apply to the request.
        """
        pass

    def close(self):
        """Cleans up adapter specific items."""
        # Nothing to clean yet
        pass


def translate_curl_exception(curl_exception):
    """This function will make the best effort to translate a given PyCURL error
    to a requests exception.

    Args:
        curl_exception (pycurl.error): PyCURL error to be translated.

    Returns:
        requests.exceptions.RequestException: the requests exception that
            matches to the CURL error.
    """

    error_code, error_msg = curl_exception.args

    return ConnectionError(error_msg)
